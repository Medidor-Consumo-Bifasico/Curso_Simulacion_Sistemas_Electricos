#include <Arduino.h>

#include "HAL_Sensor.h"

// Sensor
MedidorTrifasico Sensor;

#define NEXTION_SERIAL_TX GPIO_NUM_22
#define NEXTION_SERIAL_RX GPIO_NUM_21

int page = 0;

// PANTALLA TRIANGULO POTENCIA
NexPage page_TrianglePower = NexPage(0, 0, "page0");
NexButton back_TP = NexButton(0, 5, "b0");
NexButton continue_TP = NexButton(0, 6, "b1");
NexText text_P3 = NexText(0, 2, "t0");
NexText text_Q3 = NexText(0, 3, "t1");
NexText text_S3 = NexText(0, 4, "t2");
NexButton opcion_3P = NexButton(0, 7, "b2");
NexButton opcion_3Q = NexButton(0, 8, "b3");
NexButton opcion_3S = NexButton(0, 9, "b4");

// PANTALLA POTENCIA TRIFASICA
NexPage page_P3 = NexPage(1, 1, "page1");
NexButton home_P3 = NexButton(1, 2, "b0");
NexText text_P31 = NexText(1, 3, "t0");
NexText text_P32 = NexText(1, 4, "t1");
NexText text_P33 = NexText(1, 5, "t2");

// PANTALLA POTENCIA REACTIVA TRIFASICA
NexPage page_Q3 = NexPage(2, 2, "page2");
NexButton home_Q3 = NexButton(2, 2, "b0");
NexText text_Q31 = NexText(2, 3, "t0");
NexText text_Q32 = NexText(2, 4, "t1");
NexText text_Q33 = NexText(2, 5, "t2");

// PANTALLA POTENCIA APARENTE TRIFASICA
NexPage page_S3 = NexPage(3, 3, "page3");
NexButton home_S3 = NexButton(3, 2, "b0");
NexText text_S31 = NexText(3, 3, "t0");
NexText text_S32 = NexText(3, 4, "t1");
NexText text_S33 = NexText(3, 5, "t2");

// PANTALLA VOLTAJE LINEA NEUTRO
NexPage page_VoltajeNeutro = NexPage(4, 4, "page4");
NexButton back_VN = NexButton(4, 3, "b0");
NexButton continue_VN = NexButton(4, 2, "b1");
NexText text_VLN1 = NexText(4, 4, "t0");
NexText text_VLN2 = NexText(4, 5, "t1");
NexText text_VLN3 = NexText(4, 6, "t2");

// PANTALLA CORRIENTE LINEA
NexPage page_Corriente = NexPage(5, 5, "page5");
NexButton back_I = NexButton(5, 2, "b0");
NexButton continue_I = NexButton(5, 3, "b1");
NexText text_I1 = NexText(5, 4, "t0");
NexText text_I2 = NexText(5, 5, "t1");
NexText text_I3 = NexText(5, 6, "t2");

// PANTALLA VECTORES
NexPage page_Vector = NexPage(7, 7, "page7");
NexButton back_Vector = NexButton(7, 8, "b0");
NexButton continue_Vector = NexButton(7, 9, "b1");

NexGauge GaugeFase1 = NexGauge(7, 2, "z0");
NexGauge GaugeFase2 = NexGauge(7, 3, "z1");
NexGauge GaugeFase3 = NexGauge(7, 4, "z2");

NexText text_Vector1 = NexText(7, 5, "t0");
NexText text_Vector2 = NexText(7, 6, "t1");
NexText text_Vector3 = NexText(7, 7, "t2");

// TOUCH
NexTouch *nex_listen_list[] =
    {

        &back_TP,
        &continue_TP,

        &opcion_3P,
        &opcion_3Q,
        &opcion_3S,

        &home_P3,
        &home_Q3,
        &home_S3,

        &back_VN,
        &continue_VN,

        &back_I,
        &continue_I,

        &back_Vector,
        &continue_Vector,

        NULL};

void ChangePage(int page)
{
  switch (page)
  {
  case 0:
    page_TrianglePower.show();
    break;

  case 1:
    page_VoltajeNeutro.show();
    break;

  case 2:
    page_Corriente.show();
    break;

  case 3:
    page_Vector.show();
    break;
  }
}

void P3_PopCallback(void *ptr)
{
  page_P3.show();
  page = 31;
}

void Q3_PopCallback(void *ptr)
{
  page_Q3.show();
  page = 32;
}

void S3_PopCallback(void *ptr)
{
  page_S3.show();
  page = 33;
}

void Home_PopCallback(void *ptr)
{
  page = 0;
  page_TrianglePower.show();
}

void DownPagePopCallback(void *ptr)
{
  page--;
  if (page < 0)
  {
    page = 3;
  }
  ChangePage(page);
}

void UpPagePopCallback(void *ptr)
{
  page++;
  if (page > 3)
  {
    page = 0;
  }
  ChangePage(page);
}

void UpdatePage(int page)
{
  char buffer[20];
  uint32_t numberA;
  uint32_t numberB;
  uint32_t numberC;

  switch (page)
  {
  case 0:
    sprintf(buffer, "%d.%02d[kW]", (int)Sensor.P3, (int)(Sensor.P3 * 100) % 100);
    text_P3.setText(buffer);
    sprintf(buffer, "%d.%02d[kVAR]", (int)Sensor.Q3, (int)(Sensor.Q3 * 100) % 100);
    text_Q3.setText(buffer);
    sprintf(buffer, "%d.%02d[kVA]", (int)Sensor.S3, (int)(Sensor.S3 * 100) % 100);
    text_S3.setText(buffer);
    break;

  case 1:
    sprintf(buffer, "%d.%02d[V]", (int)Sensor.DatosFaseA.VLN, (int)(Sensor.DatosFaseA.VLN * 100) % 100);
    text_I1.setText(buffer);
    sprintf(buffer, "%d.%02d[V]", (int)Sensor.DatosFaseB.VLN, (int)(Sensor.DatosFaseB.VLN * 100) % 100);
    text_I2.setText(buffer);
    sprintf(buffer, "%d.%02d[V]", (int)Sensor.DatosFaseC.VLN, (int)(Sensor.DatosFaseC.VLN * 100) % 100);
    text_I3.setText(buffer);
    break;

  case 2:
    sprintf(buffer, "%d.%02d[A]", (int)Sensor.DatosFaseA.I, (int)(Sensor.DatosFaseA.I * 100) % 100);
    text_I1.setText(buffer);
    sprintf(buffer, "%d.%02d[A]", (int)Sensor.DatosFaseB.I, (int)(Sensor.DatosFaseB.I * 100) % 100);
    text_I2.setText(buffer);
    sprintf(buffer, "%d.%02d[A]", (int)Sensor.DatosFaseC.I, (int)(Sensor.DatosFaseC.I * 100) % 100);
    text_I3.setText(buffer);
    break;

  case 3:
    // uint32_t aA = (int)Sensor.DatosFaseA.angule * (180 / PI);
    // uint32_t aB = (int)Sensor.DatosFaseB.angule * (180 / PI);
    // uint32_t aC = (int)Sensor.DatosFaseC.angule * (180 / PI);

    numberA = Sensor.DatosFaseA.angule * (180 / PI);
    numberB = Sensor.DatosFaseB.angule * (180 / PI);
    numberC = Sensor.DatosFaseC.angule * (180 / PI);

    Serial.println(numberA);
    Serial.println(numberB);
    Serial.println(numberC);

    GaugeFase1.setValue(numberA);
    GaugeFase2.setValue(numberB);
    GaugeFase3.setValue(numberC);

    sprintf(buffer, "%d°", (int)numberA);
    text_Vector1.setText(buffer);

    sprintf(buffer, "%d°", (int)numberA);
    text_Vector2.setText(buffer);

    sprintf(buffer, "%d°", (int)numberA);
    text_Vector3.setText(buffer);

    break;

  case 31:
    sprintf(buffer, "%d.%02d[kW]", (int)Sensor.DatosFaseA.P, (int)(Sensor.DatosFaseA.P * 100) % 100);
    text_I1.setText(buffer);
    sprintf(buffer, "%d.%02d[kW]", (int)Sensor.DatosFaseB.P, (int)(Sensor.DatosFaseB.P * 100) % 100);
    text_I2.setText(buffer);
    sprintf(buffer, "%d.%02d[kW]", (int)Sensor.DatosFaseC.P, (int)(Sensor.DatosFaseC.P * 100) % 100);
    text_I3.setText(buffer);
    break;

  case 32:
    sprintf(buffer, "%d.%02d[kVAR]", (int)Sensor.DatosFaseA.Q, (int)(Sensor.DatosFaseA.Q * 100) % 100);
    text_I1.setText(buffer);
    sprintf(buffer, "%d.%02d[kVAR]", (int)Sensor.DatosFaseB.Q, (int)(Sensor.DatosFaseB.Q * 100) % 100);
    text_I2.setText(buffer);
    sprintf(buffer, "%d.%02d[kVAR]", (int)Sensor.DatosFaseC.Q, (int)(Sensor.DatosFaseC.Q * 100) % 100);
    text_I3.setText(buffer);
    break;

  case 33:
    sprintf(buffer, "%d.%02d[kVA]", (int)Sensor.DatosFaseA.S, (int)(Sensor.DatosFaseA.S * 100) % 100);
    text_I1.setText(buffer);
    sprintf(buffer, "%d.%02d[kVA]", (int)Sensor.DatosFaseB.S, (int)(Sensor.DatosFaseB.S * 100) % 100);
    text_I2.setText(buffer);
    sprintf(buffer, "%d.%02d[kVA]", (int)Sensor.DatosFaseC.S, (int)(Sensor.DatosFaseC.S * 100) % 100);
    text_I3.setText(buffer);
    break;
  }
}

void setup()
{
  nexSerial.begin(9600, SERIAL_8N1, NEXTION_SERIAL_RX, NEXTION_SERIAL_TX);
  delay(1000);

  // CONFIGURAMOS LOS BOTONES PARA DESPLAZARNOS
  back_TP.attachPop(DownPagePopCallback, &back_TP);
  continue_TP.attachPop(UpPagePopCallback, &continue_TP);

  back_VN.attachPop(DownPagePopCallback, &back_VN);
  continue_VN.attachPop(UpPagePopCallback, &continue_VN);

  back_I.attachPop(DownPagePopCallback, &back_I);
  continue_I.attachPop(UpPagePopCallback, &continue_I);

  back_Vector.attachPop(DownPagePopCallback, &back_I);
  continue_Vector.attachPop(UpPagePopCallback, &continue_I);

  // CONFIGURAMOS LOS BOTONES DE LAS POTENCIAS
  opcion_3P.attachPop(P3_PopCallback, &opcion_3P);
  opcion_3Q.attachPop(Q3_PopCallback, &opcion_3Q);
  opcion_3S.attachPop(S3_PopCallback, &opcion_3S);

  home_P3.attachPop(Home_PopCallback, &home_P3);
  home_Q3.attachPop(Home_PopCallback, &home_Q3);
  home_S3.attachPop(Home_PopCallback, &home_S3);

  page_TrianglePower.show();

  Serial.begin(115200);
}

void loop()
{
  nexLoop(nex_listen_list);
  Sensor.GetMedicionTrifasica();
  UpdatePage(page);
  delay(100);
}